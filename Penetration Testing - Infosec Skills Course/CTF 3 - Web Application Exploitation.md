In this lab, we will explore Server-Side Request Forgery (SSRF), a common web application vulnerability. Our goals are to understand how SSRF works, identify its risks to internal systems, and learn how to prevent it.

Simple nmap first: `nmap 192.168.1.100 -sV`

The url has "id=2" which can be changed to "id=1" and the password be changed for admin user!
From there we get the password for `alice` as `armando10`

Then we can ssh to that user and get the flag!
`ssh alice@192.168.1.100`

`CA{JX$AMTF9n5}`

# Privilege escalation
Check user's permissions: `sudo -l`
Here the user can use nano as `sudo` so open nano.
We go to `https://gtfobins.github.io/` to get the vulnerabilities that we can exploit.

We have a vulnerability were nano does not drop the escalated privilege: 
https://gtfobins.github.io/gtfobins/nano/#sudo

If the binary is allowed to run as superuser by `sudo`, it does not drop the elevated privileges and may be used to access the file system, escalate or maintain privileged access.

```
    sudo nano
    ^R^X
    reset; sh 1>&0 2>&0
```

Then we will have a shell within nano we can execute shell commands such as `ls` `cat` etc. and we read the `flag.txt`

`CA{SG$dCZ6d2}`
# Mitigation

SSRF (Server-Side Request Forgery) is a vulnerability commonly found in web applications. To mitigate this risk, it is essential to follow best practices:

- Input Validation: Strictly validate and sanitize all user input, especially URLs.
    
- Whitelist Allowed URLs: Limit outbound requests to a predefined list of permitted URLs or IP addresses.
    
- Disable Unnecessary Features: If your application does not require the ability to fetch external resources, disable those features entirely.
    

SSH is one of the most secure protocols, but it can still be vulnerable. Some best practices include:

- Changing the default SSH port
- Implementing firewall rules
- Monitoring and logging access
- Checking for misconfigurations in the SSH configuration