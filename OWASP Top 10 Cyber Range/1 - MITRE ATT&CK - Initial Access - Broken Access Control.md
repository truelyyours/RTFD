Access Control is the set of policies and mechanisms that ensure users cannot act outside their intended permissions. Authorization indicates that access is provided only to users entitled to the usage. Authorization comes in after a user is successfully authenticated and a valid session is set up. Broken Access Control presents the failure of access control mechanisms, aiming to limit or control access to resources appropriately.

Access controls are a critical defense mechanism within the application. They are responsible for deciding whether they should permit a given request to perform its attempted action or access its requested resources.

Access controls can be classified into three categories:

- Vertical access controls allow different types of users to access various application functions, such as the role of an admin and other ordinary users.
- Horizontal access controls allow the same group of users to access the same type of functionality.    
- Context-dependent access controls allow access to functionality and resources depending on the state of the application.

Broken Access Control is included in the category with the most severe web application security risk by OWASP.
# Introduction to CSRF

As indicated by its name, *Request Forgery* is a fabricated request. **Cross-Site Request Forgery, also known as CSRF**, is a common web vulnerability used by attackers to trick victims into generating a request that performs specific actions on behalf of the logged-in victim. The request is similar to standard requests generated by the user's browser; thus, the webserver executes its actions. CSRF vulnerabilities can be critical, resulting in password change, account takeover, etc.

Open the browser and visit demo.com on port 5000.
`demo.com:5000
To begin, click on the CSFR link. The link presents a login page. In it, type the following default credentials (username: `admin`, password: `admin`) to continue.
# Start Burp Suite

Burp Suite is a tool that comes in helpful when attacking websites and web applications. Burp Suite acts as a proxy, controlling the flow of traffic between an attacker's browser and the target.
# Configuring Firefox

Go to the "Proxy" > "Intercept" tab and make sure that the interception action is on.

To configure Firefox for testing with Burp, go to the Firefox Menu and select Preferences.
Click on 'Manual proxy configuration'. Afterwards, set the IP address to `127.0.0.1` and the Burp Proxy listener port to `8080`. To finish, click `OK` to close all of the options dialogs.
# Changing color

When logging into the application, the student is presented with a page that has an input field asking to enter the favorite color. Make sure that the interception action is on prior to submitting.
Any value submitted will be stored in the session of the user. Type blue and click on the Submit button. The request details will be captured and shown in BurpSuite.
### Capture request in Burp

The captured request via Burp Suite shows that the application is performing a `POST` request, storing the typed favorite color into the user's session and displaying this back to the user on the HTML website.
![[Pasted image 20250813211521.png]]

The POST request is **not** sending any unique token; therefore, the attacker can suppose that this web application is not using any form of protection against CSRF.

Click on the "Forward" button to send the request to the server.

To perform a CSRF attack, all that's needed is for a user to have an active session on a given site and *an attacker crafty enough to trick a user into clicking on a link or a page that performs actions on the said side*. Hence the term's name: "Cross-Site", because the request does not come from the original site, and "Request Forgery" because it's a forged request by an attacker.
# Create a malicious page

An html file named evil-csrf.html is stored in the machine. This html file is a clone of the `demo.com:5000/update` page. The challenge is to **add a few lines of code** to the file to perform the malicious CSRF POST request. This will be achieved by adding a hidden `iFrame` that sends a request to the original site on behalf of the logged-in user. This request will change the value of the favorite color to 'Hacked'.

To do so, open the terminal, change the directory to `/home/kali/evilscripts`, and open the file using nano as an editor.
`cd /home/kali/evilscripts
`nano evil-csrf.html

The attacker adds a hidden `iFrame` using the `display:none` attribute and sends the form's response there. As a result, the victim does not see nor realize what has happened. Add the following lines of code at the end of the file.

`<iframe style="display:none" name="csrf-frame"></iframe>`

Since the attacker does not want the victim to see the form, the input element is given the type hidden, thus making it invisible on the web page that the victim sees.

```
<form method='POST' action='http://demo.com:5000/update' target="csrf-frame" id="csrf-form">
	<input type='hidden' name='color' value='Hacked!'>
	<input type='submit' value='submit'>
</form>
```

As the final step, the attacker includes some JavaScript inside a `script` tag to *automatically* submit the form when the page is loaded. JavaScript calls the `getElementByID()` method on the HTML document with the ID of the form ("csrf-form") that the attacker set in the second line as an argument.

`<script>document.getElementById("csrf-form").submit()</script>`

Once the form is submitted, the browser passes the victim's cookies to the original website through the HTTP POST request, making it seem as if the victim purposely changed the color to 'Hacked'.

Lastly, click on the Save button to save the changes made.
# Setup the evil python server

The challenge is to make the `evil-csrf.html` file accessible from other hosts. Therefore, start a python server on port `1337` by typing the following command in the terminal.
`sudo python3 -m http.server 1337`

The attacker can now use various social engineering attack methods to trick the victim user into clicking the malicious URL. One example includes sending an appealing email to the victim.
# Visit the malicious page in browser

Next, open a new tab and load the evil page previously created by typing the following command:

`localhost:1337/evil-csrf.html

The command will now send a POST request to the application and change the color value to the new value 'Hacked!'.
# Introduction to CORS

CORS allows cross-domain HTTP data exchange, indicating that a page running at `origin A` can send/receive data from a server at `origin B`. CORS is thoroughly used in web applications where web fonts, CSS, documents, and more, are loaded from different origins, which may not be of the origin where the resources are stored.

CORS operates by adding a new HTTP header that allows the webserver to speak up to a list of whitelisted domains allowed to connect and interact with the server. This process is also browser enforced; the browser reads the header and processes accordingly.

The following CORS headers are the most used:

`-Access-Control-Allow-Origin`: This header is a response header, indicating that as soon as a request is made to the server for exchanging data, the server responds with a header informing the browser whether the request's origin is listed inside the value of the response. If the header is not present or the response header does not contain the request origin inside the header, the request is dropped, and a security error is raised; otherwise, the request is processed.

`-Access-Control-Allow-Methods`: This is another response header; the server responds with this header and instructs the browser to check for allowed HTTP methods mentioned inside of it. If the server only allows GET and a POST request is initiated, it will be dropped if not mentioned in this list.

`-Origin`: This request header tells the server from which domain origin the request was attempted. The origin header is always sent alongside cross-domain requests.

### Login using default credentials

Go back to the browser and visit demo.com:5000.
`demo.com:5000

Secondly, click on the CORS link. The student is presented with a login page. Type the following default credentials (username: `admin`, password: `admin`) to continue.
# Modify the Response Header

After successfully logging in, return to Burp Suite to view the intercepted traffic from the application. Go to the "Proxy" > "HTTP history" tab. The tab displays records of all requests that have passed through the Proxy. Secondly, click on the last transmitted request containing the "`/confidential`" URL. Burp Suite will show the relevant messages for the selected request.
![[lh0h41c7.jpg]]

The selected request shows that the application has CORS enabled and has set a wildcard for the `Access-Control-Allow-Origin` response header, indicating that any origin can access the resource.

Right-click on the request and choose `Send to Repeater` from the context menu. **Repeater** is a tool used to manually manipulate and reissue HTTP requests and analyze the application's responses. Now, visit the Repeater tab and add an "Origin" request header with the "
evilwebsite.xyz" value below the session cookie. Afterwards, click the Send button.
`Origin: evilwebsite.xyz`

The user will find out that the value from the added Origin header is dynamically allocated to the "Access-Control-Allow-Origin" header.
![[ms3sk36n.jpg]]
# Create a malicious Javascript code

An html file named `evil-cors.html` is saved in the machine. The challenge is to add a few lines of code for performing a malicious `XMLHttpRequest` GET request. **XHR (XMLHttpRequest)** objects are used to retrieve data from a URL without doing a full page refresh. To get started, open a new tab in terminal and edit the file `evil-cors.html` located in `~/evilscripts`.

The student must perform an `XMLHttpRequest GET request` from the malicious domain to obtain sensitive information. Therefore, to send an HTTP request, create an `XMLHttpRequest object` named `req`. Insert the following lines of code inside the element.
`<script>
	`var req = new XMLHttpRequest();`

Set the `req.onload` listener function to get the response from the server and populate the result afterwards.

    `req.onload = reqListener;`

Call the open function to start the request. The first argument is the HTTP request method, which in this case is `GET`. The second argument is the URL or relative path to the server-side resource. The third argument is for assessing whether the HTTP request occurs asynchronously. Set it to true since it is not needed to hold up other parts of JavaScript code from loading.

    `req.open('get','http://demo.com:5000/confidential', true);`

Use the send() method to send the request to the server.

    `req.withCredentials = true;
    req.send(); 
    function reqListener(){ document.getElementById("cors").innerHTML= req.responseText; } </script>`

![[Screenshot 2025-02-19 at 10.06.00-1 1.png]]

Save the changes and close the editor.

